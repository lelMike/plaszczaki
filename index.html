<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Documentation</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #e0e0e0;
        }

        .container {
            width: 80%;
            margin: 2% auto;
            padding: 20px;
            background: #1e1e1e;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        h1, h2 {
            color: #61dafb;
        }

        h1 {
            border-bottom: 2px solid #61dafb;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .accordion {
            margin-bottom: 40px;
        }

        .accordion h2 {
            background-color: #333;
            padding: 15px;
            cursor: pointer;
            border: none;
            text-align: left;
            outline: none;
            transition: background-color 0.3s ease;
            margin: 0;
            border-radius: 5px;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .accordion h2:hover {
            background-color: #444;
        }

        .panel {
            padding: 0 18px;
            background-color: #1e1e1e;
            display: none;
            overflow: hidden;
            border-top: 1px solid #444;
            border-radius: 0 0 5px 5px;
            transition: max-height 0.3s ease-out;
        }

        h3 {
            color: #e0e0e0;
        }

        .panel p code {
            background-color: #333;
            color: #61dafb;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
        }

        .panel p {
            margin: 10px 0;
        }

        .footer {
            margin-top: 40px;
            text-align: center;
        }

        .footer a {
            color: #61dafb;
            text-decoration: none;
        }

        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background-color: #61dafb;
            color: #121212;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            display: none;
            transition: background-color 0.3s ease;
        }

        .back-to-top:hover {
            background-color: #4fa3d5;
        }

        .search-bar {
            width: calc(100% - 36px);
            padding: 10px;
            margin: 20px 18px;
            background-color: #333;
            border: none;
            border-radius: 5px;
            color: #e0e0e0;
        }

        .dark-mode-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #61dafb;
            color: #121212;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .dark-mode-toggle:hover {
            background-color: #4fa3d5;
        }

        .light-mode {
            background-color: #f0f0f0;
            color: #121212;
        }

        .light-mode .container {
            background: #ffffff;
        }

        .light-mode .accordion h2 {
            background-color: #ccc;
        }

        .light-mode .accordion h2:hover {
            background-color: #bbb;
        }

        .light-mode .panel {
            background-color: #f9f9f9;
            border-top: 1px solid #ccc;
        }

        .light-mode .back-to-top,
        .light-mode .dark-mode-toggle {
            background-color: #333;
            color: #f0f0f0;
        }

        .light-mode .back-to-top:hover,
        .light-mode .dark-mode-toggle:hover {
            background-color: #444;
        }

        mark {
            background-color: #ff0;
            color: #000;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Płaszczaki Project Documentation</h1>
    <input type="text" class="search-bar" id="searchBar" placeholder="Search...">

    <div class="accordion">
        <h2>Problem 1</h2>
        <div class="panel">
            <h3>Opis problemu</h3>
            <p>Paniczny chaos zapanował. Zdecydowano, że jacyś intruzi spoza Kraju musieli zamienić literę b w słowie "boli" na p. Aby chronić piękną historię-melodię napisaną na Stronie, zdecydowano się zbudować wokół niej płot. Aby chronić piękną historię-melodię napisaną na Stronie, zdecydowano się zbudować wokół Kraju płot, używając punktów orientacyjnych. Płot zostanie zbudowany z odcinków o długości 1 (mogą być cięte). Odcinki będą przenoszone przez tragarzy. Wśród tragarzy są dwa rodzaje: ci z rękami z tyłu i ci z rękami z przodu. W dwuwymiarowym świecie nie można przenieść rąk (z przodu na tył i odwrotnie). Aby przenieść odcinek, potrzebny jest tragarz z rękami z tyłu i drugi z rękami z przodu. Nie wszyscy tragarze lubią się nawzajem i nie zawsze chcą ze sobą współpracować. Konieczne jest staranne dobieranie tragarzy w pary. Rysunek 2: Po lewej przyjaźni tragarze przenoszący odcinek prawidłowo, po prawej kłótliwi tragarze, którzy nie chcą współpracować Rysunek 3: Przyjaźni tragarze, którzy nie mogą przenieść odcinka, ponieważ ich ręce są po tej samej stronie Odcinki są produkowane w fabryce, a następnie przenoszone siecią wąskich dróg do punktów zbiorczych. Problem. Określić, jak odcinki są transportowane z fabryki na miejsce budowy płotu. Zbudować płot tak szybko i tanio, jak to możliwe.</p>

            <h3>Nasza interpretacja</h3>
            <p>Ten problem można podzielić na dwa podproblemy. Pierwszy problem to, mając dany zestaw pracowników oraz określone warunki i relacje, celem jest obliczenie maksymalnej liczby możliwych par. Drugi problem to generowanie granicy wokół zbioru punktów i konstruowanie sieci przepływu między nimi, na podstawie określonych kryteriów krawędzi. Obliczenie potrzebne, to ilość dni potrzebnych do zbudowania muru wokół granicy, jeśli pary pracowników mogłyby składać elementy muru wokół każdego punktu granicznego.</p>

            <h3>Instrukcje uruchomienia</h3>
            <p>Ten program działa w 3 trybach.</p>

            <p>
                Pierwszy tryb pozwala użytkownikowi wybrać pliki .txt z konsoli i wyświetla odpowiedź w konsoli:<br>
                <code>.\build1.bat</code>
            </p>

            <p>
                Drugi tryb jest rozszerzeniem pierwszego, dodatkowo wyświetla informacje debugowania w konsoli:<br>
                <code>.\build1.bat debug</code>
            </p>

            <p>
                Trzeci tryb to tryb testowy, pozwalający przeprowadzić serię testów bez potrzeby ręcznego wprowadzania każdej nazwy pliku .txt:<br>
                <code>.\build1.bat test</code>

                Każdy tryb ma interfejs GUI, do pokazywania skonstruowanego grafu, zbudowany w SFML.
            </p>

            <h3>Pliki</h3>
            <p>Rozwiązanie tego problemu składa się z:<br>
                <code>problem1.cpp</code>
                <code>WorkerRelations.cpp</code><code>WorkerRelations.h</code><code>BorderHandler.cpp</code>
                <code>BorderHandler.h</code>
                <code>GraphHandler.cpp</code><code>GraphHandler.h</code>
            </p>

            <h3>Dane wejściowe</h3>
            <p>W każdym przypadku testowym potrzebne są 2 pliki .txt. Pierwszy plik zawiera szczegóły dotyczące pracowników i ich relacji (p[x]_w[x].txt). Drugi plik zawiera wszystkie punkty i ich współrzędne, a także krawędzie określone z określoną wartością przepływu (p[x]_c[x].txt).</p>

            <h3>Dane wyjściowe</h3>
            <p>Po każdym obliczeniu granicy, liczba punktów granicznych oraz losowo wygenerowane wartości jasności od 1 do 100 dla każdego z nich są przechowywane w pliku p3_path[x].txt do wykorzystania w problemie 3.</p>

            <h3>Testy</h3>
            <p>Seria przeprowadzonych testów jest widoczna w folderze /txt. Większość została wygenerowana za pomocą skryptu GenerateTests.py, z dodatkowymi testami stworzonymi ręcznie w celu przetestowania przypadków brzegowych. Przykłady obejmują: Brak par pracowników, Mniej niż 4 punkty testowe, test fabryki będącej częścią granicy, testy wrażliwe na wartości zmiennoprzecinkowe (dla możliwych błędów zmiennoprzecinkowych), dziwne testy graniczne.</p>

            <h3>Złożoność i dowód</h3>
            <p>Używane algorytmy to:<br>
                - Algorytm Jarvisa (obliczenie granicy, z pomocą Natana); Złożoność O(N*H), gdzie N to całkowita liczba punktów, a H to całkowita liczba punktów leżących w otoczce wypukłej (granicy),<br>
                - Dostosowany algorytm Forda-Fulkersona (dla sieci przepływu i ścieżki powiększającej); Dostosowany, ponieważ dodaję wirtualny węzeł zlewni, aby obsłużyć wiele zlewni w algorytmie. Złożoność nadal pozostaje bazowa O(E*|F|), gdzie E to liczba krawędzi, a |F| to maksymalny przepływ, ponieważ dodatkowe operacje związane z obsługą wirtualnej zlewni są zarządzalne w ramach tej złożoności,<br>
                - Algorytm Hopcrofta-Karpa (Znajdowanie maksymalnego skojarzenia w strukturze danych par); Złożoność O(E*sqrt(V)), gdzie E to liczba krawędzi w grafie dwudzielnym, a V to liczba wierzchołków,<br>
                - Dostosowany algorytm filtrowania par; Złożoność O(n), gdzie n to rozmiar wektora upodobań przekazywanego do funkcji. Ta analiza zakłada średnią wydajność operacji na mapie skrótów, które zazwyczaj mają złożoność O(1) dla wyszukiwania i wstawiania. Ten algorytm gwarantuje zakończenie, ponieważ skończony zestaw par jest dzielony na 2 nieposortowane mapy w zależności od kierunku rąk, a następnie łączony w pary na podstawie relacji i tego, czy są one znalezione w przeciwległych mapach. Jeśli zakładamy, że nie ma warunku zatrzymania, lista pracowników musiałaby być nieskończona, ponieważ to jedyna możliwość. Jeśli nie można dopasować pracowników, zwracany jest pusty zestaw pracowników.</p>
        </div>
    </div>

        <h2>Problem 2</h2>
        <div class="panel">
            <h3>Problem description</h3>
            <p>Problem. Zapisać opowieść-melodię w maszynie Informatyka, zamieniając wcześniej „poli” na
                „boli” oraz próbując oszczędzić wykorzystane miejsce. Znaleźć rozwiązanie problemu ewentualnej
                zamiany innych fragmentów opowieści-melodii, który niepokoi Heretyka oraz Informatyka.
            </p>

            <h3>Our interpretation</h3>
            <p>
                Musimy wyszkiwać wzorzec, podmienić go, a następnie całą pieść poddać kompresji.
                W tym celu wykorzystamy algorytm Knutha-Morissa-Pratta oraz algorytm Huffmana.
            </p>

            <h3>Files</h3>
            <p>
                plik główny: problem2.cpp <br>
                plik pomocniczy z funkcjami niezwiązanymi z algorytmem KMP/Huffmana: filtering.h <br>
                wyszukiwanie wzorca: KMP.h <br>
                kompresja: huffman.h <br>
            </p>

            <h3>Input data</h3>
            <p>wejście: nasza pieśń która będzie plikiem tekstowym (z przerobionymi wyrazami), oraz plik z parami wyrazów pierwszy niepoprawny (ten w piosence) a drugi poprawny (heretyk przy użyciu swoich kontaktów z siłami nadprzyrodzonymi wie które są przerobione), wyrazy są ustawione w następujący sposób <br>
                poprawny zły<br>
                poprawny zły<br>
                itd <br>
            </p>

            <h3>Output data</h3>
            <p>wyjście: plik z pieśnią do której mają dostęp informatyk oraz heretyk, która została poddana obróbce zgodnie z tym co należy przerobić według heretyka oraz zakodowana i skompresowana zgodnie z algorytmem Huffmana </p>

            <h3>Tests</h3>
            <p>
                Łatwo idzie zauważyć, że program ten działa. Wystarczy wpisać dowolny tekst z podmienionymi paroma wyrazami, oraz uzupełnić plik tekstowy na słowa i otrzymamy naszą pieśń skompresowaną zgodnie z algorytmem Huffmana. Zastępowanie liter/wyrazów funkcjonuje bez najmniejszych problemów pragnę więc skupić się na specyficznych przypadkach:<br>

                1. wejście puste:
                W przypadku gdy jedno z wejść jest puste program nas poinformuje o zakończeniu działania.<br>
                2. nasz wyraz będzie dłuższy od tekstu/równy lub wzorzec == wyraz do podmiany
                W takim przypadku funkcja errorChecking w KMP.h zajmie się sprawdzeniem tych przypadków i odpowiednią reakcją na nie<br>
                3. wejście to pojedynczy znak
                Program ten jest przystosowany do takiej ewentualności jednakże będzie również przyjmował znak nowej linii.<br>

            </p>

            <h3>Complexity and proof</h3>
            <p>
                Przed próbą dowiedzenia poprawności pragnę zauważyć, że istnieje szansa na powstanie konfliktu w kolejności podmiany np:<br>

                rower podmieniamy na kajak<br>
                kaj podmieniamy na maj<br>

                wynikiem końcowym powinien być wyraz majak jednakże rozważmy następującą sytuację:<br>

                kaj -> maj<br>
                rower -> kajak<br>

                Łatwo idzie zauważyć, że bez odpowiedniej reakcji wynikiem końcowym będzie wyraz kajak, albowiem nie znajdziemy na początku dopasowania dla kaj. W związku z czym musimy nasz zbiór wyrazów posortować względem liczby znaków, a dokładniej rzecz ujmując malejąco.<br>


                Pomimo posortowania malejąco dalej możemy natrafić na konflikt, weźmy pod uwagę następującą sytuację:<br>
                a -> b<br>
                c -> d<br>
                b -> c<br>

                Posortowane pod względem rozmiaru ewidentnie to jest, jednakże nadal występuje konflikt, albowiem dla wejścia:<br>
                aaa<br>
                otrzymamy:<br>
                ccc<br>

                Powodem tego jest to, iż nie posortowaliśmy naszego wejścia (wyrazów do podmiany) leksykograficznie, po takim działaniu będziemy mieli następującą kolejność:<br>
                a -> b<br>
                b -> c<br>
                c -> d<br>

                Czyli dla naszego wejścia aaa wyjściem będzie ddd.<br>

                Możemy starać się z całego serca zredukować konflikt jednakże to jeszcze nie jest koniec, bo co w sytuacji gdy:<br>

                a -> z<br>
                c -> a<br>
                z -> b<br>

                Długość wyrazów ta sama? Jest. Wyraz do podmiany posortowany leksykograficznie? Również jest. To dlaczego dalej mamy konflikt?<br>
                W celu otrzymania pełnej poprawność musimy jeszcze wyrazy zastępujące również posortować leksykograficznie.<br>
                Przykład we/wy może być analogiczny do poprzedniego więc pozostawię go wyobraźni.<br>

                Reszta kodu to jest algorytm Knutha Morrisa Pratta oraz algorytm Huffamana które zostały już dawno dowiedzione przez ludzi z znacznie większą wiedza ode mnie więc zaufam im na słowo.<br>

                Ogólna złożoność czasowa:<br>
                Złożoność KMP: O(k⋅(n+m), gdzie k to liczba wywołań pattern, n to długość tekstu, a m to długość wzorca.<br>
                Złożoność Huffmana: O(n logn) dla tworzenia drzewa, O(n) dla kompresji i dekompresji.<br>
                Ogólna uproszczona złożoność: O(k * (n + m) + n * log n)<br>

                Złożoność przestrzenna:<br>
                Odczyt plików: O(n), gdzie n to liczba znaków w pliku.<br>
                Algorytm KMP: O(n) dla przechowywania wzorców i tekstu.<br>
                Algorytm Huffmana: O(n) dla przechowywania drzewa i skompresowanego tekstu.<br>

            </p>
        </div>

        <h2>Problem 3</h2>
        <div class="panel">
            <h3>Our interpretation</h3>
            <p>Problem trzeci w mojej interpretacji wyglądał następująco: Wybudowanego w pierwszym zadaniu płotu należy pilnować. Takie zadanie mają płaszczaki, które pełnią funkcję strażnika. Każdy z nich ma losowo dobraną energię (od 1-10). Na jej podstawie wybierany jest grafik - im strażnik ma większą energię, tym pierwszy jest w kolejce do grafiku. Należy też przestrzegać paru ważnych zasad: ⦁ strażnicy mogą mieć urlopy, ⦁ po pilnowaniu muszą odbyć 7 dni odpoczynku, aby móc ponownie patrolować płot. Każdy punkt płotu ma swoją jasność w skali 1-100 (współrzędne w mojej interpretacji nie mają znaczenia). W inpucie dostajemy dodatkową ilośc kroków strażników, po których muszą sie zatrzymać i rozejrzeć. Jeśli ta ilość równa się trzy, płaszczak może się zatrzymać po jednym, dwóch i trzech krokach, najważniejsze jest, aby punkt na którym się zatrzyma, był ciemniejszy od poprzedniego. Dla punktów 3 18 2 najkorzystniejsze jest przejście z punktu z jasnością 3 do punktu z jasnością 2, ponieważ 2 ma mniejszą jasność niż 18. Jest to ważne w kontekście zadania, ponieważ gdy w sytuacji gdy mamy punkty 30 31 32 zatrzymując się i na punkcie z jasnością 31, i na punkcie z jasnością 32 trafiamy na punkty jaśniejsze, przez którą strażnicy muszą przesłuchać melodię, a słuchanie jej często bardzo nudzi płaszczaków. W takiej sytuacji lepiej przejść do punktu 32, wtedy ilość przesłuchań melodii jest mniejsza. W programie dążę do ustalenia grafiku strażnikow z uwzględnieniem ich losowo wygenerowanej energii, urlopów oraz 7 dni odpoczynku oraz do ustalenia ścieżki, gdzie liczba przesłuchań melodii jest najmniejsza.</p>

            <h3>Files</h3>
            <p>Pliki nagłówkowe: route.h, guards.h Pliki główne: problem3.cpp (main), guards.cpp, route.cpp ANALIZY PLIKÓW problem3.cpp To jest funkcja główna. Łączy ona wszystkie 5 plików ze sobą. W środku znajduje się automatyczne wczytywanie testów, wczytywanie informacji z dwóch plików, losowanie energii strażnikow, inicjalizacja map analizujących urlopy i energie, sprawdzanie najkorzystniejszej ilości przesłuchań melodii oraz wypisanie wyniku na terminal. guards.cpp Połączona jest z plikiem nagłówkowym guards.h Ten plik ma za zadanie stworzenie grafiku strażników na podstawie energii, dni urlopowych i wymaganych 7 dni odpoczynku. Jest to analizowane na podstawie map nieposortowanych oraz kolejki priorytetowej route.cpp W tym pliku wybieramy najkorzystniejszą ścieżkę, aby ilość przesłuchań melodii była jak najmniejsza. W tej funkcji wraz z Natanem i Mikołajem uwzględniliśmy zatrzymywanie się na każdym punkcie i analizowaniu, czy jest jaśniejszy/ciemniejszy od poprzedniego. Jeśli żaden z punktów nie był ciemniejszy, zatrzymuje się na kroku o wartości max_steps (maksymalna ilość kroków) nalicza nam jedno wysłuchanie melodii i jeden krok. W programie uwzględniłam wypisanie ilości zatrzymań, które zrobił strażnik, aby łatwiej było przeanalizować poprawność kroków strażnika. Program uwzględnia ruch do punktu ostatniego i analizowanie przesłuchań i jasności - wtedy strażnik wybiera się na odpoczynek.</p>

            <h3>Input data</h3>
            <p>Input w moim rozwiązaniu polega na dwóch plikach: ⦁ problem3.vacationx (x - numer testu) - odpowiadający za ilość analizowanych dni, kroków oraz dni wolnych strażników ⦁ problem3.pathx - odpowiadający za ilość punktów i poziomu jasności punktów</p>

            <h3>Output data</h3>
            <p>W outpucie mamy numer testu, poszczególne energie każdego strażnika, a następnie grafik oraz liczba przesłuchań melodii</p>

            <h3>Tests</h3>
            <p>Testy przeprowadzałam na wielu przypadkach w tym mowa o tych skrajnych: np: ⦁ wszyscy strażnicy mają urlop 1-ego dnia ⦁ jeden strażnik ma urlop każdego dnia ⦁ każde kolejne punkty są od siebie większe ⦁ uwzględnione 14 dni zamiast 7</p>
        </div>
    </div>

    <div class="footer">
        <p id="datetime"></p>
        <p><a href="https://github.com/lelMike/plaszczaki/tree/master?tab=readme-ov-file" target="_blank">Back to GitHub Repository</a></p>
    </div>
</div>

<button class="back-to-top" onclick="scrollToTop()">Back to Top</button>
<button class="dark-mode-toggle" onclick="toggleDarkMode()">Toggle Dark/Light Mode</button>

<script>
    document.querySelectorAll('.accordion h2').forEach(button => {
        button.addEventListener('click', () => {
            const panel = button.nextElementSibling;
            if (panel.style.display === "block") {
                panel.style.display = "none";
            } else {
                document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
                panel.style.display = "block";
                window.scrollTo({
                    top: button.offsetTop,
                    behavior: 'smooth'
                });
            }
        });
    });

    function scrollToTop() {
        window.scrollTo({top: 0, behavior: 'smooth'});
    }

    window.addEventListener('scroll', () => {
        const backToTopButton = document.querySelector('.back-to-top');
        if (window.scrollY > 100) {
            backToTopButton.style.display = 'block';
        } else {
            backToTopButton.style.display = 'none';
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        const datetimeElement = document.getElementById('datetime');
        const now = new Date();
        const formattedDateTime = now.toLocaleString();
        datetimeElement.textContent = `Date and Time: ${formattedDateTime}`;
    });

    function toggleDarkMode() {
        document.body.classList.toggle('light-mode');
    }

    const searchBar = document.getElementById('searchBar');
    searchBar.addEventListener('input', function() {
        const searchText = searchBar.value.toLowerCase();
        document.querySelectorAll('.accordion h2').forEach(header => {
            const panel = header.nextElementSibling;
            const text = panel.textContent.toLowerCase();
            const regex = new RegExp(searchText, 'gi');

            panel.innerHTML = panel.innerHTML.replace(/(<mark class="highlight">|<\/mark>)/gim, "");
            const html = panel.innerHTML;

            if (text.includes(searchText)) {
                header.style.display = '';
                panel.innerHTML = html.replace(regex, (match) => `<mark class="highlight">${match}</mark>`);
                panel.style.display = 'block';
            } else {
                header.style.display = 'none';
                panel.style.display = 'none';
            }

            if (searchText === "") {
                header.style.display = '';
                panel.innerHTML = html.replace(/(<mark class="highlight">|<\/mark>)/gim, "");
                panel.style.display = 'none';
            }
        });
    });
</script>
</body>
</html>
