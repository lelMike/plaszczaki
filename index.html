<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Documentation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #e0e0e0;
        }
        .container {
            width: 80%;
            margin: auto;
            overflow: hidden;
            padding: 20px;
            background: #1e1e1e;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        h1, h2 {
            color: #e0e0e0;
        }
        h1 {
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }
        .accordion {
            margin-bottom: 40px;
        }
        .accordion h2 {
            background-color: #333;
            padding: 10px;
            cursor: pointer;
            border: none;
            text-align: left;
            outline: none;
            transition: background-color 0.3s ease;
        }
        .accordion h2:hover {
            background-color: #444;
        }
        .panel {
            padding: 0 18px;
            background-color: #1e1e1e;
            display: none;
            overflow: hidden;
            border-top: 1px solid #444;
        }
        h3 {
            color: #e0e0e0;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Płaszczaki Project Documentation</h1>

    <div class="accordion">
        <h2>Problem 1</h2>
        <div class="panel">
            <h3>Problem description</h3>
            <p><!-- Problem 1 description goes here --></p>

            <h3>Our interpretation</h3>
            <p><!-- Our interpretation of problem 1 goes here --></p>

            <h3>Files</h3>
            <p><!-- List of files related to problem 1 --></p>

            <h3>Input data</h3>
            <p><!-- Input data for problem 1 --></p>

            <h3>Output data</h3>
            <p><!-- Output data for problem 1 --></p>

            <h3>Tests</h3>
            <p><!-- Tests for problem 1 --></p>

            <h3>Complexity and proof</h3>
            <p><!-- Complexity and proof for problem 1 --></p>
        </div>

        <h2>Problem 2</h2>
        <div class="panel">
            <h3>Problem description</h3>
            <p><!-- Problem 2 description goes here --></p>

            <h3>Our interpretation</h3>
            <p><!-- Our interpretation of problem 2 goes here --></p>

            <h3>Files</h3>
            <p><!-- List of files related to problem 2 --></p>

            <h3>Input data</h3>
            <p><!-- Input data for problem 2 --></p>

            <h3>Output data</h3>
            <p><!-- Output data for problem 2 --></p>

            <h3>Tests</h3>
            <p><!-- Tests for problem 2 --></p>

            <h3>Complexity and proof</h3>
            <p><!-- Complexity and proof for problem 2 --></p>
        </div>

        <h2>Problem 3</h2>
        <div class="panel">
            <h3>Our interpretation</h3>
            <p><Problem trzeci w mojej interpretacji wyglądał następująco:
Wybudowanego w pierwszym zadaniu płotu należy pilnować. Takie zadanie mają płaszczaki, które pełnią funkcję strażnika. Każdy z nich ma losowo dobraną energię (od 1-10). Na jej podstawie wybierany jest grafik - im strażnik ma większą energię, tym pierwszy jest w kolejce do grafiku. Należy też przestrzegać paru ważnych zasad:
⦁	strażnicy mogą mieć urlopy,
⦁	po pilnowaniu muszą odbyć 7 dni odpoczynku, aby móc ponownie patrolować płot.
 Każdy punkt płotu ma swoją jasność w skali 1-100 (współrzędne w mojej interpretacji nie mają znaczenia). W inpucie dostajemy dodatkową ilośc kroków strażników, po których muszą sie zatrzymać i rozejrzeć. Jeśli ta ilość równa się trzy, płaszczak może się zatrzymać po jednym, dwóch i trzech krokach, najważniejsze jest, aby punkt na którym się zatrzyma, był ciemniejszy od poprzedniego. 
Dla punktów 3 18 2 najkorzystniejsze jest przejście z punktu z jasnością 3 do punktu z jasnością 2, ponieważ 2 ma mniejszą jasność niż 18.
Jest to ważne w kontekście zadania, ponieważ gdy w sytuacji gdy mamy punkty 30 31 32 zatrzymując się i na punkcie z jasnością 31, i na punkcie z jasnością 32 trafiamy na punkty jaśniejsze, przez którą strażnicy muszą przesłuchać melodię, a słuchanie jej często bardzo nudzi płaszczaków. W takiej sytuacji lepiej przejść do punktu 32, wtedy ilość przesłuchań melodii jest mniejsza.
W programie dążę do ustalenia grafiku strażnikow z uwzględnieniem ich losowo wygenerowanej energii, urlopów oraz 7 dni odpoczynku oraz do ustalenia ścieżki, gdzie liczba przesłuchań melodii jest najmniejsza.
></p>


            <h3>Files</h3>
            <p><Pliki nagłówkowe: route.h, guards.h
Pliki główne: problem3.cpp (main), guards.cpp, route.cpp
ANALIZY PLIKÓW
problem3.cpp
To jest funkcja główna. Łączy ona wszystkie 5 plików ze sobą.
W środku znajduje się automatyczne wczytywanie testów, wczytywanie informacji z dwóch plików, losowanie energii strażnikow, inicjalizacja map analizujących urlopy i energie, sprawdzanie najkorzystniejszej ilości przesłuchań melodii oraz wypisanie wyniku na terminal.
guards.cpp
Połączona jest z plikiem nagłówkowym guards.h
Ten plik ma za zadanie stworzenie grafiku strażników na podstawie energii, dni urlopowych i wymaganych 7 dni odpoczynku. Jest to analizowane na podstawie map nieposortowanych oraz kolejki priorytetowej
route.cpp
W tym pliku wybieramy najkorzystniejszą ścieżkę, aby ilość przesłuchań melodii była jak najmniejsza. W tej funkcji wraz z Natanem i Mikołajem uwzględniliśmy zatrzymywanie się na każdym punkcie i analizowaniu, czy jest jaśniejszy/ciemniejszy od poprzedniego. Jeśli żaden z punktów nie był ciemniejszy, zatrzymuje się na kroku o wartości max_steps (maksymalna ilość kroków) nalicza nam jedno wysłuchanie melodii i jeden krok. W programie uwzględniłam wypisanie ilości zatrzymań, które zrobił strażnik, aby łatwiej było przeanalizować poprawność kroków strażnika. Program uwzględnia ruch do punktu ostatniego i analizowanie przesłuchań i jasności - wtedy strażnik wybiera się na odpoczynek.
></p>

            <h3>Input data</h3>
            <p><Input w moim rozwiązaniu polega na dwóch plikach:
⦁	problem3.vacationx (x - numer testu) - odpowiadający za ilość analizowanych dni, kroków oraz dni wolnych strażników
⦁	problem3.pathx - odpowiadający za ilość punktów i poziomu jasności punktów
></p>

            <h3>Output data</h3>
            <p><W outpucie mamy numer testu, poszczególne energie każdego strażnika, a następnie grafik oraz liczba przesłuchań melodii></p>

            <h3>Tests</h3>
            <p><Testy przeprowadzałam na wielu przypadkach w tym mowa o tych skrajnych:
np:
⦁	wszyscy strażnicy mają urlop 1-ego dnia
⦁	jeden strażnik ma urlop każdego dnia
⦁	każde kolejne punkty są od siebie większe
⦁	uwzględnione 14 dni zamiast 7
></p>
        </div>
    </div>
</div>

<script>
    document.querySelectorAll('.accordion h2').forEach(button => {
        button.addEventListener('click', () => {
            const panel = button.nextElementSibling;
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        });
    });
</script>
</body>
</html>
